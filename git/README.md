# Git 入门梳理

以一个git新手的角度来阐述项目中git的使用，理解git的基本原理，总结出操作手册，期待能以这篇记录做一次轻量级的分享。

## 目录
* [为什么 Git](#为什么 Git)
	* [SVN 的痛点](#SVN 的痛点)
	* [Git 的诞生](#Git 的诞生)
* [介绍 Git](#介绍 Git)
	* [主分支 Mater](#主分支 Mater)  



### 为什么 Git
#### SVN 的痛点
`svn`是典型的集中式的版本控制系统，版本库集中存放在中央服务器，可以多人共同维护一份中央服务器的代码，在我过去使用`svn`这种集中式的版本控制系统，有时候总能感受到多人协作时对整体项目的不可控风险的痛点，SVN的处理方式在我看来略有欠缺。  
比如 想多人开发同一个前端项目时，不同人修改了不同文件，在以前前端没有构建流程整体打包的情况下发布流程还算好，我们只需要保证我们本次提交的单个或几个代码文件的可上线状态，其他修改文件不部署线上，就没有关系。  
但是现代化的前端工程化流程来了，面临上线时候我们通常需要整体打包构建，这个时候我们必须要不能提交的代码文件会滚到可上线的稳定版本，然后构建打包，构建出一个整体`dist`代码版本，这个过程中，需要部署工程师本人对项目的整个开发改动非常熟悉，才能保证，上线前构建的每一个代码文件都是稳定可上线的。  
上完线之后，我们需要把之前功能迭代的非上线代码给回滚回来，继续功能开发。这个过程非常的手工化，非常的蛋疼和危险。  
有时候，我们当然也会使用SVN的Branch分支功能，但是因为SVN的分支功能过笨重，每次分支合并到主干几乎都是一次战斗，我们要谨防出现冲突和手工记录此次的合并操作，因为SVN无法识别合并和手工修改。

####  Git 的诞生
Git传说当中是由Linux之父为了解决Linux代码维护管理的问题花了2周时间用C语言写出的分布式版本控制系统。Git诞生以来，主要是依靠它极其强大且没有包袱的分支管理，把SVN等远远抛在了后面，当然Git还有一个区别SVN的优点，就是Git的commit不需要联网，我们可以仅仅依靠本地commit记录版本的提交信息。

### 介绍Git 
#### 主分支 Mater
我们的代码库都应该又一个主分支。所有提供给用户使用的正式版本，都在这个分支上发布。
#### 开发分支 Develop
主分支只用来分布重大版本，日常开发应该在另一条分支上完成。我们把开发用的分支，叫做Develop。

### 创建版本库

版本库又名仓库，英文名 repository。我们通过创建仓库，让一个目录下所有的文件都被Git版本控制和追踪。

```
git init
```

只需要一条命令，瞬间就在当前文件夹创建好了一个Git仓库。

#### 把文件添加到 Git 仓库

第一步，用命令`git add`告诉Git，把文件添加到仓库。

第二步，用命令`git commit`告诉Git，把文件和提交信息提交到仓库。

这个过程中请注意，Unix的哲学是“没有消息就是好消息”，如果没有错误提示，那就是成功了。

```
git add readme.md
git commit -m ‘wrote a readme file’
```

### Git版本控制

我们使用`git status`来查看仓库当前的状态，使用`git diff`来查看修改的内容。

我们有时候需要回退版本，查看历史记录，我们使用`git log`命令查看，如果觉得输出信息太多，眼花缭乱，我们可以试试加上`git log --pretty=oneline`参数。

```
$ git log --pretty=oneline
3628164fb26d48395383f8f31179f24e0882e1e0 third commit
ea34578d5496d7dd233c827ed32a8cd576c5ee85 second commit
cb926e7ea50ad11b8f9e909c05226233bf755030 first commit
```
我们看到的一大串类似`3628164fb26d48395383f8f31179f24e0882e1e0`的就是我们git的`commmit id`（版本号），和svn版本号的1，2，3...递增不一样，Git因为是分布式的版本控制系统，如果大家都是1，2，3，4就肯定不好处理了，所以我们用一个SHA1计算出的一个不会重复的非常大的16进制数字串，作为每一次提交的版本号。

接下来，我们想回退到上一个版本。在Git中，用`HEAD`表示当前版本，也就是最新的提交`third commit`，上一个版本就是`HEAD^`，上上个版本就是`HEAD^^`,我们要是回退比较多，可以表示成这样`HEAD-100`。

现在我们使用`git reset`命令来回退到上一个版本：

```
git reset --hard HEAD^
```

> `--hard`参数的意义，在这里暂时留下一个疑问，后面进行解释。


同样如果没有提示错误，我们就成功了。但是此时，我们再使用`git log`，发现最新的版本已经不见了。

其实还是有办法，我们使用`git reflog`命令找到以前的commit id，再使用

```
git reflog
ea34578 HEAD@{0}: reset: moving to HEAD^
3628164 HEAD@{1}: commit: third commit
ea34578 HEAD@{2}: commit: second commit
cb926e7 HEAD@{3}: commit (initial): first commit
git reset --hard 3628164
```

版本号其实没不需要写全，前几位就可以了，Git会自动查找。Git版本回退的速度非常快，因为在Git内部有个指向当前版本的HEAD指针，当你回退版本的时候，Git迅速把HEAD的指向改变，然后改变去更新文件库文件。

小结：

- `HEAD`指向的版本就是当前版本，Git的版本回退的命令为`git reset --hard commit_id`
- `git log`可以查看历史提交信息，以便确定要回到哪个版本。
- 若要重返未来，用`git reflog`查看历史命令信息，以便确定要回到未来的哪个版本。


### 工作区和暂存区

工作区也就是我们的系统文件夹内，有一个隐藏目录`.git`,是Git的版本库。

我们把文件往Git版本库里添加的时候，是分两步执行的：

第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区；

第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。

git add命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行git commit就可以一次性把暂存区的所有修改提交到分支。

### 管理修改

> 为什么Git比其他版本控制系统设计得优秀，因为Git跟踪并管理的是修改，而非文件。

Git是如何跟踪修改的，每次修改，如果不add到暂存区，那就不会加入到commit中。

### 撤销修改

`git checkout -- file`可以丢弃工作区的修改,把指定文件在工作区的修改全部撤销。

`git checkout -- file`命令中的`--`很重要，没有`--`，就变成了“切换到另一个分支”的命令。

### 删除文件

`git rm test.txt`

命令`git rm`用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。

### 远程仓库

- 添加远程库

要关联一个远程库，使用命令`git remote add origin git@server-name:path/repo-name.git`

关联后，使用命令`git push -u origin master`第一次推送master分支的所有内容；

此后，每次本地提交后，只要有必要，就可以使用命令`git push origin master`推送最新修改；

分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！

- 从远程库克隆

要克隆一个仓库，首先必须知道仓库的地址，然后使用`git clone`命令克隆。

Git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快。


### 分支管理

分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。

现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。

其他版本控制系统如SVN等都有分支管理，但是用过之后你会发现，这些版本控制系统创建和切换分支比蜗牛还慢，简直让人无法忍受，结果分支功能成了摆设，大家都不去用。

但Git的分支是与众不同的，无论创建、切换和删除分支，Git在1秒钟之内就能完成！无论你的版本库是1个文件还是1万个文件。

### 创建与合并分支

git的切换分支其实只是改变了`HEAD`的指向。

git鼓励大量使用分支来管理项目的开发流程协作。

查看分支：`git branch`

创建分支：`git branch <name>`

切换分支：`git checkout <name>` 

创建+切换分支：`git checkout -b <name>`

合并某分支到当前分支：`git merge <name>`

删除分支：`git branch -d <name>`

### 解决冲突

当两个分支merge出现相同工作区的编辑时，就不能快速自动合并，git会把各种的修改保存，让我们手动解决冲突。

`git log --graph`命令可以查看分支合并图

### 分支合并策略

通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。

如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。

`--no-ff`方式的`git merge`：

```
git merge --no--ff -m ’merge width --no--ff‘ dev
```

这样方式的合并要创建一个新的commit，所以加上`-m`参数，把commit描述写进去。

小结
> 合并分支时，加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。

### 分支管理策略

在实际开发中，我们应该按照几个基本原则进行分支管理：

首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；

那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；

你和你的小伙伴们每个人都在从dev划出的分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。

### Bug分支



###
























